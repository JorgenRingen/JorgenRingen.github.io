<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on </title>
    <link>https://jorgenringen.github.io/blog/</link>
    <description>Recent content in Blog on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 28 Jan 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jorgenringen.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Logging: Distributed tracing with Spring Cloud Sleuth</title>
      <link>https://jorgenringen.github.io/2018/01/tracing_with_spring_cloud_sleuth/</link>
      <pubDate>Sun, 28 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jorgenringen.github.io/2018/01/tracing_with_spring_cloud_sleuth/</guid>
      <description>Spring Cloud Sleuth is a framework for enhancing logging and diagnostics, especially in a distributed microservice architecture. Sleuth makes it possible to correlate log-statements relating to a specific requests, scheduled jobs, etc within an application or even across multiple application.
Terminology:
 SLF4J - Standard logging API for java Trace - Can be thought of as a single request in an application or spanning across multiple applications. Spans - Can be thought of as sections/parts of a trace.</description>
    </item>
    
    <item>
      <title>Design patterns: Factory method naming conventions</title>
      <link>https://jorgenringen.github.io/2018/01/factory_method_naming_conventions/</link>
      <pubDate>Tue, 02 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jorgenringen.github.io/2018/01/factory_method_naming_conventions/</guid>
      <description>Factory method pattern naming conventions The ‚Äúfactory method‚Äù is a very useful pattern, but it has som limitations when it comes to documentation. Constructors ‚Äústand out‚Äù in API documentation and are easy to spot, but factory methods on the other hand can be hard to find. There are some naming conventions laid out in effective java that can reduce this problem and make the factory methods easier to find in an IDE.</description>
    </item>
    
    <item>
      <title>Strategies for managing data in microservices</title>
      <link>https://jorgenringen.github.io/2017/12/stategies_managing_data_in_microservices/</link>
      <pubDate>Fri, 29 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jorgenringen.github.io/2017/12/stategies_managing_data_in_microservices/</guid>
      <description>Strategies for managing data in microservices In this post, we‚Äôll look at some common patterns for managing data in a distributed microservice architecture. Managing data in a monolithic application is fairly easy and well understood, but in a microservice architecture it can be a lot more challenging and different patterns are needed. By just re-using patterns from the monolithic world we often end up with poor results and this anti-pattern is often known as the ‚Äúdistributed monolith‚Äù.</description>
    </item>
    
    <item>
      <title>Jacoco coverage plugin in multimodule maven projects</title>
      <link>https://jorgenringen.github.io/2017/09/jacoco_multimodule_maven/</link>
      <pubDate>Sun, 03 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jorgenringen.github.io/2017/09/jacoco_multimodule_maven/</guid>
      <description>I&amp;rsquo;ve created a simple dummy-project that demonstrates how to configure the jacoco code coverage library in a multi-module maven project with integration-tests in order to get a complete coverage-report.
Problem One of the problems with jacoco and maven is that coverage is only reported for code in the module in which the tests are located and not for the entire project as a whole. This means that the coverage-percent will be under-reported in many cases.</description>
    </item>
    
    <item>
      <title>Logging: Simple way to trace related log statements in an application</title>
      <link>https://jorgenringen.github.io/2016/08/logging_rename_thread_name/</link>
      <pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://jorgenringen.github.io/2016/08/logging_rename_thread_name/</guid>
      <description>Ever seen this kind of output in your logs?
[0m18:33:51,083 INFO [org.example.business.PersonResource] (default task-2) Validation error. Returning status-code 400  What&amp;rsquo;s the problem with this log-message?¬†We know that some validation has failed and that a status-code 400 was returned. Other than that it doesn&amp;rsquo;t provide a lot more information¬†other than the time of the event and the name of the class that logged the message.
How can we find any related log-statements to the error?</description>
    </item>
    
    <item>
      <title>JavaEE: Externalising configuration with ZooKeeper</title>
      <link>https://jorgenringen.github.io/2015/10/javaee_configuration_zookeeper/</link>
      <pubDate>Thu, 01 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jorgenringen.github.io/2015/10/javaee_configuration_zookeeper/</guid>
      <description>An important principle in continuous delivery is to build application binaries only once and let the exact same binary flow through each step of the build pipeline in order to verify that the binary is ready for production.
A typical build pipeline might look something like this:
 Commit stage (build, unit test, analysis) Automated acceptance tests Capacity testing User acceptance testing Production  Many of these steps will often require different application configuration.</description>
    </item>
    
    <item>
      <title>JavaEE: Timestamps on entities with entitylistener</title>
      <link>https://jorgenringen.github.io/2015/07/javaee_timestamps_entities_entitylistener/</link>
      <pubDate>Wed, 01 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jorgenringen.github.io/2015/07/javaee_timestamps_entities_entitylistener/</guid>
      <description>This post shows how you can add timestamps¬†to¬†your entities in a non-intrusive unified way with plain JPA.
We start off with an embeddable JPA entity, TimeStamp:
import javax.persistence.Column; import javax.persistence.Embeddable; import java.util.Date; @Embeddable public class TimeStamp { @Column(name = &amp;#34;date_created&amp;#34;) @Temporal(TemporalType.TIMESTAMP) private Date created; @Column(name = &amp;#34;date_updated&amp;#34;) @Temporal(TemporalType.TIMESTAMP) private Date updated; // getters, setters, etc } We also need a simple interface that our entities should implement:
public interface EntityWithTimeStamp { void setTimeStamp(TimeStamp timeStamp); TimeStamp getTimeStamp(); } Lets add an entity which implements our interface:</description>
    </item>
    
    <item>
      <title>Java8: Stream and Lambda code kata</title>
      <link>https://jorgenringen.github.io/2015/06/java8_stream_lambda_code_kata/</link>
      <pubDate>Thu, 04 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jorgenringen.github.io/2015/06/java8_stream_lambda_code_kata/</guid>
      <description>I just added a code kata for learning the Stream and Lambda API&amp;rsquo;s in Java 8.
The purpose of a¬†kata¬†is to repeat a simple exercise over and over again, making small¬†improvements for each iteration, until you basically can do the exercise blind folded. I find this to be one of the most effective ways to improve basic coding skills and to learn new things.
Feel free to fork and submit your own &amp;ldquo;perfectionized&amp;rdquo; solution.</description>
    </item>
    
    <item>
      <title>JavaEE: Using JSR310 time-types in JAX-RS</title>
      <link>https://jorgenringen.github.io/2015/05/javaee_jsr310_types_with_jaxrs/</link>
      <pubDate>Thu, 21 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jorgenringen.github.io/2015/05/javaee_jsr310_types_with_jaxrs/</guid>
      <description>With Java 8 came¬†the JSR310 Date and Time API, a new and improved date and time API for Java. This post¬†will show you how you can use types from JSR310¬†directly in¬†JAX-RS s by only leveraging the Java EE api.
JavaEE dependency:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javaee-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;7.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; Create a simple Person-class with a field, birthDate, of type java.time.LocalDate from JSR310:
public class Person { ... private LocalDate birthDate; .</description>
    </item>
    
  </channel>
</rss>