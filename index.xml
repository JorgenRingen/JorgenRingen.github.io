<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>https://jorgenringen.github.io/</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 12 Dec 2017 19:04:34 +0100</lastBuildDate>
    
	<atom:link href="https://jorgenringen.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://jorgenringen.github.io/about/</link>
      <pubDate>Tue, 12 Dec 2017 19:04:34 +0100</pubDate>
      
      <guid>https://jorgenringen.github.io/about/</guid>
      <description>Scribblings about topics such Java, Java EE, Spring, microservices, etc.</description>
    </item>
    
    <item>
      <title>Jacoco coverage plugin in multimodule maven projects</title>
      <link>https://jorgenringen.github.io/2017/09/jacoco_multimodule_maven/</link>
      <pubDate>Sun, 03 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jorgenringen.github.io/2017/09/jacoco_multimodule_maven/</guid>
      <description>I&amp;rsquo;ve created a simple dummy-project that demonstrates how to configure the jacoco code coverage library in a multi-module maven project with integration-tests in order to get a complete coverage-report.
Problem One of the problems with jacoco and maven is that coverage is only reported for code in the module in which the tests are located and not for the entire project as a whole. This means that the coverage-percent will be under-reported in many cases.</description>
    </item>
    
    <item>
      <title>JavaEE: Externalising configuration with ZooKeeper</title>
      <link>https://jorgenringen.github.io/2015/10/javaee_configuration_zookeeper/</link>
      <pubDate>Thu, 01 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jorgenringen.github.io/2015/10/javaee_configuration_zookeeper/</guid>
      <description>An important principle in continuous delivery is to build application binaries only once and let the exact same binary flow through each step of the build pipeline in order to verify that the binary is ready for production.
A typical build pipeline might look something like this:
 Commit stage (build, unit test, analysis) Automated acceptance tests Capacity testing User acceptance testing Production  Many of these steps will often require different application configuration.</description>
    </item>
    
    <item>
      <title>JavaEE: Timestamps on entities with entitylistener</title>
      <link>https://jorgenringen.github.io/2015/07/javaee_timestamps_entities_entitylistener/</link>
      <pubDate>Wed, 01 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jorgenringen.github.io/2015/07/javaee_timestamps_entities_entitylistener/</guid>
      <description>This post shows how you can add timestamps to your entities in a non-intrusive unified way with plain JPA.
We start off with an embeddable JPA entity, TimeStamp:
import javax.persistence.Column; import javax.persistence.Embeddable; import java.util.Date; @Embeddable public class TimeStamp { @Column(name = &amp;#34;date_created&amp;#34;) @Temporal(TemporalType.TIMESTAMP) private Date created; @Column(name = &amp;#34;date_updated&amp;#34;) @Temporal(TemporalType.TIMESTAMP) private Date updated; // getters, setters, etc } We also need a simple interface that our entities should implement:
public interface EntityWithTimeStamp { void setTimeStamp(TimeStamp timeStamp); TimeStamp getTimeStamp(); } Lets add an entity which implements our interface:</description>
    </item>
    
    <item>
      <title>Java8: Stream and Lambda code kata</title>
      <link>https://jorgenringen.github.io/2015/06/java8_stream_lambda_code_kata/</link>
      <pubDate>Thu, 04 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jorgenringen.github.io/2015/06/java8_stream_lambda_code_kata/</guid>
      <description>I just added a code kata for learning the Stream and Lambda API&amp;rsquo;s in Java 8.
The purpose of a kata is to repeat a simple exercise over and over again, making small improvements for each iteration, until you basically can do the exercise blind folded. I find this to be one of the most effective ways to improve basic coding skills and to learn new things.
Feel free to fork and submit your own &amp;ldquo;perfectionized&amp;rdquo; solution.</description>
    </item>
    
    <item>
      <title>JavaEE: Using JSR310 time-types in JAX-RS</title>
      <link>https://jorgenringen.github.io/2015/05/javaee_jsr310_types_with_jaxrs/</link>
      <pubDate>Thu, 21 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jorgenringen.github.io/2015/05/javaee_jsr310_types_with_jaxrs/</guid>
      <description>With Java 8 came the JSR310 Date and Time API, a new and improved date and time API for Java. This post will show you how you can use types from JSR310 directly in JAX-RS s by only leveraging the Java EE api.
JavaEE dependency:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javaee-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;7.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; Create a simple Person-class with a field, birthDate, of type java.time.LocalDate from JSR310:
public class Person { ... private LocalDate birthDate; .</description>
    </item>
    
  </channel>
</rss>